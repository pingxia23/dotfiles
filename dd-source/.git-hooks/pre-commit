#!/bin/bash
set -euo pipefail

# --------------------------- Color Definitions --------------------------- #
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
GREY='\033[0;37m'
RED='\033[0;31m'
NC='\033[0m'

# ---------------------------- Helper Functions ---------------------------- #
log() {
    local color="$1"
    local message="$2"
    echo -e "${color}${message}${NC}"
}

info() { log "${BLUE}" "$1"; }
success() { log "${GREEN}" "$1"; }
warn() { log "${YELLOW}" "$1"; }
error() { log "${RED}" "$1"; }

# This will be set once in the main execution
MERGE_BASE=""

stage_generated_files() {
    local current_files=$(git diff --name-only)
    local original_files=$BEFORE_HOOK
    local original_staged=$BEFORE_HOOK_STAGED

    if [[ "$original_files" != "$current_files" ]]; then
        warn "üìù Changes detected. Adding modified files to commit..."
        while IFS= read -r file; do
            if [[ "$original_staged" == *"$file"* || "$original_files" != *"$file"* ]]; then
                info "  üìù Adding: $file"
                git add "$file"
            fi
        done <<< "$current_files"
    fi
}

# Returns files eligible for processing - SINGLE SOURCE OF TRUTH for merge detection
# During merge: only files changed in our branch (not incoming merge files)
# Normal commit: all staged files
get_my_branch_files() {
    if [[ -f .git/MERGE_HEAD ]]; then
        git diff --name-only "$MERGE_BASE"..HEAD
    else
        git diff --name-only --staged
    fi
}

diff_for_file() {
    local file="$1"
    if [[ -n "$MERGE_BASE" ]]; then
        git diff -U0 "$MERGE_BASE"..HEAD -- "$file"
    else
        git diff --cached -U0 -- "$file"
    fi
}

# --------------------------- Change Detectors --------------------------- #
# All detectors use get_my_branch_files as input (centralized filtering)

get_proto_dirs() {
    get_my_branch_files | {
        local dirs=""
        while IFS= read -r file; do
            [[ "$file" == *.proto ]] && dirs+=" $(dirname "$file")"
        done
        echo "$dirs" | xargs -n1 2>/dev/null | sort -u | xargs
    }
}

get_go_generate_files() {
    get_my_branch_files | {
        local files=""
        while IFS= read -r file; do
            [[ "$file" == *.go ]] && [[ -f "$file" ]] && grep -q "//go:generate" "$file" 2>/dev/null && files+=" $file"
        done
        echo "$files" | xargs
    }
}

get_go_import_dirs() {
    get_my_branch_files | {
        local dirs=""
        while IFS= read -r file; do
            [[ "$file" == *.go ]] || continue
            [[ -f "$file" ]] || continue

            if diff_for_file "$file" | grep -Eq '^[+-][[:space:]]*import[[:space:]]*(\\(|")|^[+-][[:space:]]*"[^"]+"'; then
                dirs+=" $(dirname "$file")"
            fi
        done
        echo "$dirs" | xargs -n1 2>/dev/null | sort -u | xargs
    }
}

get_bazel_dirs() {
    get_my_branch_files | {
        local dirs=""
        while IFS= read -r file; do
            [[ "$file" == *.bazel ]] && dirs+=" $(dirname "$file")"
        done
        echo "$dirs" | xargs -n1 2>/dev/null | sort -u | xargs
    }
}

get_go_embed_dirs() {
    get_my_branch_files | {
        local packages=""
        while IFS= read -r file; do
            [[ -f "$file" ]] || continue
            local dir=$(dirname "$file")
            if find "$dir" -maxdepth 1 -name '*.go' -exec grep -l "//go:embed" {} \; 2>/dev/null | head -1 | grep -q .; then
                packages+=" $dir"
            fi
        done
        echo "$packages" | xargs -n1 2>/dev/null | sort -u | xargs
    }
}

get_python_files() {
    get_my_branch_files | {
        local files=""
        while IFS= read -r file; do
            if [[ "$file" == *.py || "$file" == *.pyi ]]; then
                # Exclude protobuf-generated files
                if [[ "$file" != *_pb2.py && "$file" != *_pb2.pyi && "$file" != *_pb2_grpc.py && "$file" != *_pb2_grpc.pyi ]]; then
                    files+=" $file"
                fi
            fi
        done
        echo "$files" | xargs
    }
}

get_assistant_python_files() {
    get_my_branch_files | {
        local files=""
        while IFS= read -r file; do
            if [[ "$file" == domains/assistant/*.py || "$file" == domains/assistant/*.pyi ]]; then
                # Exclude protobuf-generated files
                if [[ "$file" != *_pb2.py && "$file" != *_pb2.pyi && "$file" != *_pb2_grpc.py && "$file" != *_pb2_grpc.pyi ]]; then
                    files+=" $file"
                fi
            fi
        done
        echo "$files" | xargs
    }
}

get_python_import_dirs() {
    get_my_branch_files | {
        local dirs=""
        while IFS= read -r file; do
            if [[ "$file" == *.py || "$file" == *.pyi ]]; then
                if [[ "$file" != *_pb2.py && "$file" != *_pb2.pyi && "$file" != *_pb2_grpc.py && "$file" != *_pb2_grpc.pyi ]]; then
                    [[ -f "$file" ]] || continue
                    if diff_for_file "$file" | grep -Eq '^[+-][[:space:]]*(import|from)[[:space:]]'; then
                        dirs+=" $(dirname "$file")"
                    fi
                fi
            fi
        done
        echo "$dirs" | xargs -n1 2>/dev/null | sort -u | xargs
    }
}

get_go_files() {
    get_my_branch_files | {
        local files=""
        while IFS= read -r file; do
            [[ "$file" == *.go ]] && [[ -f "$file" ]] && files+=" $file"
        done
        echo "$files" | xargs
    }
}

# --------------------------- Main Execution --------------------------- #
# Dynamically determine repo root (works in any clone location)
REPO_ROOT=$(git rev-parse --show-toplevel)
cd "$REPO_ROOT"

BEFORE_HOOK=$(git diff --name-only)
BEFORE_HOOK_STAGED=$(git diff --name-only --staged)

# Cache merge-base once (used by get_my_branch_files/diff_for_file)
if [[ -f .git/MERGE_HEAD ]]; then
    MERGE_BASE=$(git merge-base HEAD MERGE_HEAD || true)
    if [[ -z "$MERGE_BASE" ]]; then
        error "‚ùå Could not determine merge-base; aborting pre-commit."
        exit 1
    fi
fi

# Show merge status if applicable
if [[ -f .git/MERGE_HEAD ]]; then
    warn "üîÄ Merge detected - only processing files from your branch"
fi

# --------------------------- Protobuf Generation --------------------------- #
warn "üîç Checking for modified .proto files..."
proto_dirs=$(get_proto_dirs)
if [[ -z "$proto_dirs" ]]; then
    info "  üïµ No .proto file edited. Skipping protobuf generation."
else
    warn "  üïµ Modified .proto files detected. Generating protobuf..."
    # Batch all proto directories into a single bzl run command
    targets=""
    for dir in $proto_dirs; do
        targets+=" //$dir/..."
    done
    info "  üöÄ Running: bzl run //:snapshot --$targets"
    bzl run //:snapshot --$targets >/dev/null 2>&1
fi

# --------------------------- Go Generate Handling --------------------------- #
warn "üîç Checking for '//go:generate' directives..."
generate_files=$(get_go_generate_files)
if [[ -z "$generate_files" ]]; then
    info "  üïµ No '//go:generate' directives found."
else
    warn "  üöÄ Found '//go:generate' directives. Running generation..."
    for file in $generate_files; do
        info "  üöÄ Generating: $file"
        go generate "$file" >/dev/null 2>&1
    done
fi

stage_generated_files

# --------------------------- Dependency Management --------------------------- #
warn "üîç Analyzing code dependencies..."
import_dirs=$(get_go_import_dirs)
python_import_dirs=$(get_python_import_dirs)
bazel_dirs=$(get_bazel_dirs)
embed_dirs=$(get_go_embed_dirs)

all_dirs=$(echo "$import_dirs $python_import_dirs $bazel_dirs $embed_dirs" | xargs -n1 2>/dev/null | sort -u | xargs)

if [[ -n "$all_dirs" ]]; then
    warn "  üöÄ Updating build files..."
    info "  üöÄ Running: bzl run //:gazelle -- $all_dirs"
    if bzl run //:gazelle -- $all_dirs >/dev/null 2>&1; then
        success "  ‚úÖ Build files updated"
        git add -u $all_dirs/*.bazel 2>/dev/null || true
    else
        warn "  ‚ö†Ô∏è Gazelle encountered issues"
    fi
else
    info "  üïµ No dependency changes detected"
fi

# --------------------------- Formatting --------------------------- #
warn "üîç Formatting Go files..."
go_files=$(get_go_files)
if [[ -n "$go_files" ]]; then
    info "  üõ† Formatting $(echo "$go_files" | wc -w | tr -d ' ') Go files..."
    # Use native gofmt for much better performance than bazel run
    if gofmt -w $go_files; then
        success "  ‚úÖ Go files formatted successfully"
    else
        error "  ‚ùå Go formatting failed!"
        exit 1
    fi
else
    info "  üïµ No Go files to format"
fi

stage_generated_files

# --------------------------- Python Formatting --------------------------- #
warn "üîç Formatting Python files..."
python_files=$(get_python_files)
if [[ -n "$python_files" ]]; then
    info "  üõ† Formatting $(echo "$python_files" | wc -w | tr -d ' ') Python files..."

    # Run ruff formatter
    diff_source=$(get_my_branch_files)
    if bzl run //tools/format:format_ruff -- --git-diff-file <(printf '%s\n' "$diff_source") >/dev/null 2>&1; then
        success "  ‚úÖ Python files formatted successfully"
    else
        error "  ‚ùå Python formatting failed!"
        exit 1
    fi

    # Run ruff linter
    if bzl run //tools/format:lint_ruff -- --git-diff-file <(printf '%s\n' "$diff_source") >/dev/null 2>&1; then
        success "  ‚úÖ Python linting passed"
    else
        error "  ‚ùå Python linting failed!"
        exit 1
    fi
else
    info "  üïµ No Python files to format"
fi

stage_generated_files

# --------------------------- Python Type Checking (domains/assistant) --------------------------- #
warn "üîç Checking Python types in domains/assistant..."
assistant_python_files=$(get_assistant_python_files)
if [[ -n "$assistant_python_files" ]]; then
    info "  üîé Running mypy on domains/assistant..."
    if bzl build --build_tag_filters=dd-mypy --config=mypy //domains/assistant/... 2>&1 | tee /tmp/mypy_output.txt | tail -5; then
        success "  ‚úÖ Python type checking passed"
    else
        error "  ‚ùå Python type checking failed!"
        error "  Run: bzl build --build_tag_filters=dd-mypy --config=mypy //domains/assistant/..."
        cat /tmp/mypy_output.txt | grep -E "(error|Error)" | tail -20
        exit 1
    fi
else
    info "  üïµ No Python files in domains/assistant to type-check"
fi


success "‚úÖ All pre-commit checks completed successfully! üéâ"
